---
title: Как работает Linux Network Stack, как его тюнить и мониторить
---

Источник: https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/

Итак, путь пакетика из кабеля в приложение приблизительно такой:

1. Прилетел сигнал в сетёвку
2. Сетёвка через DMA пишет свою память с пакетом в RAM
3. После чего вызывает прерывание (IRQ, то, что видно в /proc/interrupts), которое оповещает ядро о том что пакет пришёл
4. Вызывается функция (IRQ handler), которую зарегистрировал драйвер сетёвки при иниициализации.
5. IRQ завершается, в контексте этого IRQ делаются совсем уж копейки, чот вроде отложенной пометки что пора пакеты обрабатывать.
6. Дальше в дело вступает NAPI
7. `napi_schedule()` добавляет NAPI poll structure в `poll_list` для текущего CPU и где-то выставляет бит о том что ПОРА БЫ И SOFTIRQ БАХНУТЬ! Насколько я понимаю, текущий CPU это тот, кем обработалась очередь в которую пришёл пакет.
8. Так как бит выставлен, ksoftirqd работающий на данном CPU это видит.
9. Гоняемая в цикле `run_ksoftirqd()` функция выполняется.
10. `__do_softirq()` вызывает функцию, прибитую к NET_RX прерыванию, то есть `net_rx_action()`. Напомню, исполняет её УЖЕ НЕ ДРАЙВЕР, а тред ksoftirqd в ядре.
11. Теперь мы в контексте softirq. Это и есть тот самый %si, /proc/softirqs.
12. `net_rx_action` в цикле проверяет NAPI `poll_list` на наличие NAPI структур.
13. Проверяет, что `budget` и elapsed time не израсходованы и softirq не выжрало весь CPU.
14. Вызывается poll-функция зареганная драйвером при инициализации, для igb это `igb_poll()`.
15. Задача poll-функции - выжирать пакеты из кольцевых буферов в оперативной памяти (ethtool -g eth1, вот эти самые). Тут у меня всё ещё есть один пробел в знаниях, я так и не понимаю, размер ring буфера измеряется в числе дескрипторов, но я не помню, соотносятся эти дескрипторы 1 к 1 с пакетами или нет. + ring буферов столько, сколько очередей у сетёвки.
16. Дальше происходит `napi_gro_receive()` GRO (Generic Receive Offloading), если включено, это шняга очень помогающая при чистом INPUT и опасная (+ вроде бы абсолютно бесполезная) при FORWARD. Вообще тоже стоит про неё повнимательнее почитать. При включении пакеты складываются в GRO list.
17. Если GRO отключено пакеты попадают непосредственно в `net_receive_skb()`
18. `net_receive_skb()` это место, где вызывается или не вызывается **RPS**, в зависимости от того, включен он или нет. Если включен:
    1. Пакет пихается в бэклог с помощью `enqueue_to_backlog()`. Насчёт этого backlog у меня есть подозрение что `/proc/sys/net/core/netdev_max_backlog` - это он и есть. Насколько я понимаю, его можно рассматривать как дополнительный промежуточный RX-буфер, который существует для каждого CPU, даже если очередь у драйвера всего одна.
    2. Пакеты раскидываются между доступными CPU (указанными в rps_cpus очереди) для дальнейшей обработки.
    3. NAPI-структура добавляется в `poll_list` CPU, на который назначился пакет, в очередь ставится IPI (Inter-processor Interrupt), который вызовет softirq.
    4. В процессе работы ksoftirqd на назначенном CPU затем происходит то же что и выше, но poll-функция уже не `igb_poll()`, а `process_backlog()` которая разгребает input queue данного CPU.
19. Вне зависимости от RPS дальше пакет попадает в `__net_receive_skb_core` (или `__netif_receive_core()` или `__netif_receive_skb_core()`), дальше перепрыгиваний пакета с ядра на ядро^Wраспределения пакетов между ядрами уже не будет.
20. `__net_receive_skb_core()` уже имеет дело с skb, который мы в последствии и анализируем. Задача этой функции - доставлять пакеты к taps (PCAP является одним из них).
21. После taps'ов пакет попадает выше по стеку на L3, например для IPv4 это будет `ip_rcv()`
22. Дальше происходит вся фигня связанная с netfilter, iptables и роутингом
23. Дальше пакет попадает в свой UDP/TCP-стек, например в `udp_rcv()`
24. `udp_rcv()` кладёт пакет в очередь на отправку в сокет пользовательского пространства с помощью функции `udp_queue_rcv_skb()`.
25. Но перед тем как пакет попадёт в очередь к нему применяются BPF (Berkley Packet Filters) и он может до сокета и не дойти.
